# <center>微光后端招新第三题<center> 
---
## ***Task1. 变量和数据类型***
#### 1.说出这八种基本数据类型 

byte|short|int|long|float|double|boolean|char
---|---|---|---|---|---|---|---|
整数型|整数型|整数型|整数型|浮点型|浮点型|布尔类型|字符类型

#### 2.说出四种整型数据类型占用的字节数和表示范围  

byte|short|int|long
:-:|:-:|:-:|:-:|
一字节|二字节|四字节|八字节
-128 ~ 127|-32768 ~ 32767|2147483648 ~ 2147483647|-9223372036854775808 ~ 9223372036854775807  

>理解与扩展：
1.计算机的基础语言是由0，1组成的二进制语言，其中一字节代表着八个二进制位，也因此可以有$2^8$种不同而表现形式，共256种，刚好可以代表-128到127的数。同理可知$2^{16}$，$2^{32}$，$2^{64}$分别对应short,int,long。
>2.注意到float与double分别占用四字节和八字节，表示的最大数却远远大于相同字节数的int,long。经查询发现浮点数有e的存在，使表示的数可以很大，但表示不精准，会忽略一部分数值，而整数型则可以完全包含其范围内的整数。

#### 3.请回答这个过程涉及到的是自动类型转换还是强制类型转换，b的值是多少，为什么会是这个值 
- 自动类型转换
- b=52
- 自动型转换（隐式）代表从小类型转到大类型的转换，顺序如下：byte -> short -> char -> int -> long -> float -> double 由于char小于int,（前三者都）会被自动扩大到int。char属于字符串，使用国际ASCII编码，在运算时会调用其对应的代码。"0"代码对应48，因此用48+4=52，得出结果。  

>理解与扩展：
>1.对于隐式转换与显式转换，其中的“隐”与“显”其实代表着在转换时是否要写出转换后的数据类型，比如我先定义一个long huijiale = 114514，此时若将此long改为int，必须加上括号注明类型，如：int juansile = (int) huijile
>2.经查验布尔型在Java中不可参与运算（C/C++，python等似乎都可以），只能显示转换

#### 4（扩展）请了解包装类，引用类型和基本数据类型缓存池。给出下面代码的输出结果并解释原因
- false 由于有new词，因此此代码将直接建立一个全新的对象，因此地址不同，并不相等。
- true 18位于-128-127之间，所以会直接存入缓存池，在缓存池中相同int代表的对象相同，因此正确。
- false 300位于-128到127之外，因此会直接建立新的对象，不相等。
- 包装类对应着八种数据类型，由于八种数据类型并非对象，所以可以通过包装将其转化为对象，从而使其参与有关对象的框架体系及编码；引用类型会储存引用对象的地址：而基础类型储存池则作为小数值（-128-127）包装时一个临时停放点来使用。
>理解与扩展：
>在Java9及之后版本中，第一种形式已经不再推荐使用，但可以通过注解抑制警告。
---
## ***Task2.  运算符*** 

#### 5.算数运算符除了我们熟知的加减乘除（+ - * /）外，还有取余（%），自增（++），自减（--）。为了加深你对于自增运算符的理解，请执行下列代码，给出结果，并大概解释计算的过程。  

```
13
6 8
```  
- 该代码先生成了两个int整数型a，b，并分别赋予整数5，7.在代码的第三行中"++"代表给当前的数加一，但因为位置的不同，所以运算的顺序不同:"++a"是在对c的值进行运算前便加一，而"b++"是运算完c的值后才对b进行加一的操作。因此 $c=6+7=13$，而a，b则分别加一。
- "--"也同样遵循以上法则，代码中的'+" "+'能在打印出的数中留出空格，防止混乱. 



#### 6.(拓展) 若a=0010（二进制），说出 a&(-a) 的二进制形式是什么。对于任意的非负整数a，式子a&(-a)表示的数是什么，为什么得到这个结果（不用严格证明）。
- 0010
- 一个只有在a出现1的最小位的位置是一，其他均为0的数，可以显示出a的二进制形式1最早出现的位置。
- 首先需要了解补码，补码是计算机储存的最原始的数据，它由原码取反码再加一得来，加一的原因是为了防止正零和负零的出现，方便运算。原码即我们常用整数的二进制，反码是将原码中的"1","0"颠倒。所以-a的二进制形式补码为1110，"&"代表着将两边的二进制数逐位比较，将同位均为1的保存下来，其他位均为0，因此结果为0010；
- **证明**：当反码加一时，此二进位数会一直进位到0的出现，由于发生了进位，在此补码中，被进位的位置必然是0，而进位结束的位置必然是一，此位置后的数位必然与原码数值相反。根据"&"的定义，可知除此位置外的所有数位运算后必为0，而由于此位置原来的反码为0，原码必为1，因此此位必然有双1重复，运算后必为一。



---
## PS:
- 本题应该是正式进入代码和语法入门的一题，出乎意料的是我竟然感觉比前面几题简单，可能是前面工具使用不熟练导致的吧，因为不会用，所以疯狂报错，每次都要轮回很多次才能搞完:sweat_drops:（装工具装了一晚:disappointed_relieved:，git研究了一晚:cold_sweat:，idea又研究了一晚:scream:）现在的题反倒好一点（也有可能是还没做到）
- 另：后端大佬好多，感觉比不上了:sob:
- 另另：凌晨发现学长在改题，太敬业了喵:cat:，前辈辛苦了喵:thumbsup:  

### 参考网页：
https://liaoxuefeng.com/books/java/quick-start/basic/var-type/index.html
https://blog.csdn.net/sc179/article/details/108120739
https://www.w3schools.com/java/java_type_casting.asp
https://www.anime-planet.com/anime/tags/isekai
https://blog.csdn.net/Teacher_Lee_ZZSXT/article/details/79230501
https://wenku.csdn.net/answer/43450fa4f4bc41d69cf9d80ea8d322c9
https://www.w3schools.com/java/java_operators.asp
https://blog.csdn.net/qq_40979103/article/details/124680852
......